<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<title>Test Set9</title>
<style>
html, body {
    margin:0; padding:0; width:100%; height:100%; overflow:hidden; background:black;
}
canvas {
    position:fixed; top:0; left:0; width:100%; height:100%; object-fit:cover; z-index:1;
}
#set9special {
    position:fixed; top:0; left:0; width:100%; height:100%; display:none; cursor:pointer; z-index:5;
}
#startButton {
    position:fixed; top:0; left:0; width:100%; height:100%; background:transparent; border:none; cursor:pointer; z-index:10;
}
#finalText {
    position:fixed; top:50%; left:50%; transform:translate(-50%,-50%);
    font-size:5vw; color:white; font-family:'Courier New', monospace;
    text-align:center; pointer-events:none; display:none; max-width:80vw;
}
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<img id="set9special" src="images/set9special.jpg">
<div id="finalText"></div>
<audio id="audio" loop src="audio/audio9.mp3"></audio>
<button id="startButton"></button>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const transitions = [
    "images/set9trans1.jpg",
    "images/set9trans2.jpg",
    "images/set9trans3.jpg",
    "images/set9trans4.jpg",
    "images/set9final.jpg"
];

const finalText = "Fire will devour you where innocence was taken - Le feu te dévorera là où tu as pris leur innocence.";

let loadedImages = [];
const tempCanvas = document.createElement('canvas');
const tctx = tempCanvas.getContext('2d');
tempCanvas.width = canvas.width;
tempCanvas.height = canvas.height;

// --- préchargement des images ---
async function preloadImages(sources){
    const promises = sources.map(src => new Promise(resolve => {
        const img = new Image();
        img.src = src;
        img.crossOrigin = "anonymous";
        img.onload = ()=>resolve(img);
        img.onerror = ()=>resolve(img);
    }));
    loadedImages = await Promise.all(promises);
}

// --- audio ---
const audioElement = document.getElementById('audio');
const finalAudioSrc = "audio/final_scream.mp3";
const audioCtx = new (window.AudioContext||window.webkitAudioContext)();
const source = audioCtx.createMediaElementSource(audioElement);
const distortion = audioCtx.createWaveShaper();
const filter = audioCtx.createBiquadFilter();
const gainNode = audioCtx.createGain();
source.connect(distortion);
distortion.connect(filter);
filter.connect(gainNode);
gainNode.connect(audioCtx.destination);
gainNode.gain.value = 1;

function makeDistortionCurve(amount){
    const k = amount, n = 44100;
    const curve = new Float32Array(n);
    const deg = Math.PI/180;
    for(let i=0;i<n;i++){
        const x = i*2/n-1;
        curve[i] = ((3+k)*x*20*deg)/(Math.PI+k*Math.abs(x));
    }
    return curve;
}

// --- start button ---
document.getElementById('startButton').addEventListener('click', ()=>{
    audioCtx.resume();
    audioElement.play();
    document.getElementById('startButton').style.display='none';
});

// --- state machine ---
let clickCount = 0;
const maxClicks = 47;
let ratio = 0;
let finalMode = false;
let specialVisible = false;
let codeRevealed = false;

document.body.addEventListener('click', (e)=>{
    if(finalMode) return;

    if(!specialVisible && clickCount === 46){
        // Affiche set9special
        specialVisible = true;
        audioElement.pause();
        audioCtx.suspend();
        const img = document.getElementById('set9special');
        img.style.display = 'block';

        img.onclick = ()=>{
            if(!codeRevealed){
                activateFinalMode();
            } else {
                history.back();
            }
        };

        return; // bloque le click normal
    }

    if(clickCount < maxClicks) clickCount++;
    ratio = clickCount/maxClicks;

    if(clickCount === maxClicks) activateFinalMode();
});

// --- crash final ---
function activateFinalMode(){
    finalMode = true;
    audioCtx.resume();
    audioElement.src = finalAudioSrc;
    audioElement.loop = true;
    audioElement.play();
    distortion.curve = makeDistortionCurve(1500);

    const ft = document.getElementById('finalText');
    ft.innerText = finalText;
    ft.style.display = 'block';
}

// --- morphing ---
const steps = [10,20,30,40,46];
function getTransitionIndex(click){
    for(let i=0;i<steps.length;i++){
        if(click<=steps[i]){
            const prev = i===0?0:i-1;
            const alpha = (click-(i===0?0:steps[i-1]))/(steps[i]-(i===0?0:steps[i-1]));
            return {prevIndex:prev, nextIndex:i, alpha};
        }
    }
    return {prevIndex:transitions.length-2, nextIndex:transitions.length-1, alpha:1};
}

function morphImages(ctx,img1,img2,alpha){
    tctx.clearRect(0,0,tempCanvas.width,tempCanvas.height);
    tctx.globalAlpha = 1-alpha; tctx.drawImage(img1,0,0,tempCanvas.width,tempCanvas.height);
    tctx.globalAlpha = alpha; tctx.drawImage(img2,0,0,tempCanvas.width,tempCanvas.height);
    tctx.globalAlpha = 1;
    ctx.drawImage(tempCanvas,0,0,canvas.width,canvas.height);
}

// --- draw loop ---
async function draw(){
    await preloadImages(transitions);

    function frame(){
        requestAnimationFrame(frame);

        if(finalMode) {
            // fond rouge + glitch
            const w = canvas.width, h = canvas.height;
            ctx.clearRect(0,0,w,h);
            for(let i=0;i<500;i++){
                const x = Math.random()*w;
                const y = Math.random()*h;
                const bw = 10+Math.random()*50;
                const bh = 10+Math.random()*50;
                ctx.fillStyle = `rgba(255,0,0,${0.2+Math.random()*0.6})`;
                ctx.fillRect(x,y,bw,bh);
            }
            return;
        }

        if(specialVisible) return; // on ne touche plus à l'image spéciale

        // morph + glitch
        const {prevIndex,nextIndex,alpha} = getTransitionIndex(clickCount);
        morphImages(ctx, loadedImages[prevIndex], loadedImages[nextIndex], alpha);

        // glitch blocs
        const w = canvas.width, h = canvas.height;
        const blockCount = Math.floor(ratio*200);
        for(let i=0;i<blockCount;i++){
            const bx = Math.floor(Math.random()*w);
            const by = Math.floor(Math.random()*h);
            const bw = 5+Math.floor(Math.random()*30);
            const bh = 5+Math.floor(Math.random()*30);
            const tempData = ctx.getImageData(bx,by,bw,bh);
            const dx = Math.floor((Math.random()-0.5)*150*ratio);
            const dy = Math.floor((Math.random()-0.5)*150*ratio);
            ctx.putImageData(tempData,bx+dx,by+dy);
        }

        // fractures vibrantes
        const fracCount = Math.floor(ratio*50);
        const time = Date.now()*0.002;
        for(let i=0;i<fracCount;i++){
            const x1 = Math.floor(Math.random()*w);
            const y1 = Math.floor(Math.random()*h);
            const offsetX = Math.sin(time+i)*50*ratio;
            const offsetY = Math.cos(time+i)*50*ratio;
            const x2 = x1 + Math.floor(offsetX);
            const y2 = y1 + Math.floor(offsetY);
            ctx.strokeStyle = `rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},0.5)`;
            ctx.lineWidth = 1+ratio*2;
            ctx.beginPath();
            ctx.moveTo(x1,y1);
            ctx.lineTo(x2,y2);
            ctx.stroke();
        }

        // filtres CSS
        const contrast = 1 + ratio*5;
        const saturate = 1 + ratio*5;
        const hue = ratio*360;
        document.body.style.filter = `contrast(${contrast}) saturate(${saturate}) hue-rotate(${hue}deg)`;

        // audio
        distortion.curve = makeDistortionCurve(ratio*700);
        distortion.oversample='4x';
        filter.type='allpass';
        filter.frequency.value = 500+Math.random()*ratio*2000;
        audioElement.playbackRate = 1+ratio*0.8+Math.random()*0.02;
    }
    frame();
}

draw();
</script>
</body>
</html>
